# The Constrained Entity Wrapper Pattern

## Overview
The **Constrained Wrapper Pattern** is a lightweight, type-safe design pattern for wrapping raw entities (e.g., database models) with domain-specific constraints and behaviors. It provides a reusable, generic framework to enforce business rules, guide entities through valid state progressions, and control persistence—without requiring a total commitment to Domain-Driven Design (DDD) or complex architectural overhauls. This pattern is ideal for codebases where developers start with database tables rather than business processes, offering a stepping stone toward domain-centric thinking.

### Key Features
- **Generic Base**: A `Wrapper<T>` class that wraps any entity type, providing a foundation for persistence, validation, and optional state reversion.
- **Type-Specific Subclasses**: Concrete wrappers (e.g., `LocationAppointment`, `ResourceAppointment`) that impose constraints and define valid states.
- **Progression**: Methods to transition between states (e.g., `ToResourceAppointment`), reflecting business workflows.
- **Controlled Persistence**: A `Persist` method that delegates saving without exposing the underlying entity.
- **Validation**: Constraints enforced via exceptions or a `Result<T>` type, ensuring invalid states are caught early.

### Intent
The Constrained Wrapper Pattern aims to:
- Add domain logic to database-first models without disrupting existing code.
- Shift focus from raw data to business processes in a pragmatic way.
- Enable type safety and encapsulation for entities in any codebase.

## Motivation
In many projects, development begins with database tables—think `Appointment` or `Resource` classes autogenerated from a schema. While this approach is quick to start, it often leaves business logic scattered or missing, treating objects as mere data containers rather than meaningful domain concepts. Full DDD can address this, but its complexity (aggregates, repositories, bounded contexts) can overwhelm teams not ready for that leap. The Constrained Entity Wrapper Pattern offers a middle ground: it wraps these raw entities in a type-safe, constrained shell that reflects business rules and workflows, making it easy to adopt and incrementally evolve toward DDD principles.

For example, an `Appointment` from a database might have a `LocationId`, but the business requires that it’s only valid for scheduling if that ID is set. Rather than exposing the raw `Appointment` and hoping callers check it, a `LocationAppointment` wrapper enforces this constraint, turning a generic row into a domain-specific concept.

## Structure
The pattern revolves around a generic base class and specific wrappers:

### Generic Base: `Wrapper<T>`
```csharp
public abstract class Wrapper<T> where T : class  
{  
    protected readonly T Entity;  
    private T _originalEntity;  
    private bool _isDirty;  

    protected Wrapper(T entity)  
    {  
        Entity = entity ?? throw new ArgumentNullException(nameof(entity));  
        _originalEntity = null; // Lazy initialization  
        _isDirty = false;  
    }  

    public void Persist(Action<T> saveAction) => saveAction(Entity);  

    protected void MarkDirty()  
    {  
        if (!_isDirty)  
        {  
            _originalEntity = Mapper.Map<T>(Entity); // Deep copy via AutoMapper  
            _isDirty = true;  
        }  
    }  

    public void RevertToOriginal()  
    {  
        if (_isDirty && _originalEntity != null)  
        {  
            Mapper.Map(_originalEntity, Entity);  
            _isDirty = false;  
        }  
    }  

    public bool IsDirty => _isDirty;  

    // Helper for Result-based validation (optional, since you’re leaning toward exceptions)  
    protected static Result<U> Validate<U>(Func<bool> condition, string failureMessage, Func<U> create) => 
        condition() ? Result.Failure<U>(failureMessage) : Result.Success(create());  
}
```
- **Purpose**: Provides a reusable foundation for wrapping any entity type (`T`), encapsulating it, offering controlled persistence, and enabling optional reversion to the original state.
- **Key Elements**: 
  - A protected `Entity` field holds the live entity.
  - A private `_originalEntity` field lazily stores a deep copy (e.g., via AutoMapper) when changes occur.
  - An `_isDirty` flag tracks modifications, triggering the snapshot only on the first change.
  - `MarkDirty` ensures the original state is captured before alterations.
  - `RevertToOriginal` restores the entity to its initial state if modified.
  - `Persist` delegates saving to an external action (e.g., a repository).

#### State Reversion
The `Wrapper<T>` base class now supports reverting changes to scalar properties and child references (e.g., a `Location` within a `Resource`) without overhead unless changes occur. Subclasses call `MarkDirty` in setters or methods (e.g., `UpdateAddress`, `Reschedule`) to signal modifications, enabling rollback via `RevertToOriginal`. This is particularly useful for undoing edits to individual entities without affecting related collections.

#### Collection Handling
For wrappers managing modifiable collections (e.g., a `Resource` with `Appointments`), the base rollback doesn’t cover list changes (adds, removes). Parent wrappers must maintain a separate snapshot of the original collection (e.g., `_originalAppointments`) to track and revert these operations, syncing them during `Persist`. This hybrid approach balances efficiency and functionality.

#### Value Type Integration
The pattern can incorporate value types (e.g., `LocationId` as a record wrapping a `Guid`) to replace primitive types like `Guid` or `string`. These value types encapsulate domain-specific validation (e.g., rejecting empty GUIDs) and enhance type safety by distinguishing between similar primitives (e.g., `LocationId` vs. `ResourceId`). Wrappers expose these as properties, syncing them with the entity’s primitives while enforcing rules at the domain level.

### Concrete Wrappers
Subclasses inherit from `Wrapper<T>` and add domain-specific constraints, behaviors, and optionally value types. For example:

#### `LocationAppointment`
```csharp
public class LocationAppointment : Wrapper<Appointment>
{
    private LocationAppointment(Appointment appt) : base(appt)
    {
        if (appt.LocationId == Guid.Empty)
            throw new Exception("Appointment must have a valid LocationId");
        if (appt.BookedStart == DateTime.MinValue)
            throw new Exception($"{nameof(LocationAppointment)} must have a valid {nameof(Appointment.BookedStart)} date");
        if (appt.BookedEnd == DateTime.MinValue)
            throw new Exception($"{nameof(LocationAppointment)} must have a valid {nameof(Appointment.BookedEnd)} date");
    }

    public LocationId LocationId => LocationId.FromGuid(Entity.LocationId); // Value type
    public IReadOnlyCollection<SelectedAppointmentResource> SelectedAppointmentResources => Entity.SelectedAppointmentResources;
    public IReadOnlyCollection<SelectedAppointmentEmployee> SelectedAppointmentEmployees => Entity.SelectedAppointmentEmployees;
    public DateTime BookedStart => Entity.BookedStart;
    public DateTime BookedEnd => Entity.BookedEnd;

    public void SelectResource(MatchingResource matchingResource)
    {
        MarkDirty();
        this.Entity.AddSelectedResource(matchingResource);
    }

    public static LocationAppointment From(Appointment appt) => new(appt);

    public ResourceAppointment ToResourceAppointment() 
        => ResourceAppointment.From(this); // TODO: See below

    public EmployeeAppointment ToEmployeeAppointment() 
        => EmployeeAppointment.From(this);
}
```
- **Constraints**: Ensures `LocationId` is valid.
- **Progression**: Offers a path to `ResourceAppointment` or `EmployeeAppointment`.
- **Change Tracking**: Calls `MarkDirty` in `SelectResource` to enable reversion.
- **Value Type**: Uses `LocationId` instead of `Guid` for stronger typing and validation.

#### `ResourceAppointment`
```csharp
public class ResourceAppointment : Wrapper<Appointment>
{
    private ResourceAppointment(LocationAppointment locationAppointment) : base(locationAppointment.Entity)
    {
        if (locationAppointment.SelectedAppointmentResources.Count == 0)
            throw new Exception($"{nameof(ResourceAppointment)} requires one or more {nameof(SelectedAppointmentResource)}");
    }

    public IReadOnlyCollection<SelectedAppointmentResource> SelectedAppointmentResources => Entity.SelectedAppointmentResources;
    public DateTime BookedStart => Entity.BookedStart;
    public DateTime BookedEnd => Entity.BookedEnd;

    public static ResourceAppointment From(LocationAppointment locationAppointment) => new(locationAppointment);

    public Result<ParentResourceAppointment> AsParentResource(Guid parentResourceId)
        => ParentResourceAppointment.From(this, parentResourceId);

    public Result<ChildResourceAppointment> AsChildResource(Guid parentResourceId)
        => ChildResourceAppointment.From(this, parentResourceId);
}
```
- **Constraints**: Requires at least one resource.
- **Exposure**: Limits access to relevant properties.

#### Example Value Type: `LocationId`
```csharp
public record LocationId(Guid Value)
{
    public LocationId() : this(Guid.Empty) => throw new ArgumentException("LocationId cannot be empty.");
    public static LocationId FromGuid(Guid guid) => 
        guid == Guid.Empty ? throw new ArgumentException("LocationId cannot be empty.") : new LocationId(guid);
}
```

## How It Works
1. **Wrapping**: Start with a raw entity (e.g., an `Appointment` from a database).
2. **Constraint Enforcement**: Use a factory method (`From`) to create a wrapper, applying validation (e.g., exceptions for missing `LocationId`).
3. **Progression**: Transition to other wrappers (e.g., `ToResourceAppointment`) as the business process evolves, each enforcing its own rules.
4. **Modification and Reversion**: Alter the entity via wrapper methods or properties, triggering `MarkDirty` to snapshot the original state; revert using `RevertToOriginal` if needed.
5. **Persistence**: Call `Persist` with a save action (e.g., `repo.Save`) to store the entity without exposing it, syncing collections if applicable.

### Example Usage
```csharp
public static List<ChildResourceAppointment> GetChildResourceAppointmentsOfMatchingResourceIfAny(
    List<ResourceAppointment> resourceAppointments,
    List<LocationResource> locationResources, 
    MatchingResource matchingResource)
{
    var childResourceAppointmentsToReturn = new List<ChildResourceAppointment>();
    
    // If this matchingResource is a parent on other resources then we need to check for any appointments
    // in the child resources and if they have appointments we need to build our availabilities based on
    // when all the children are available.
    var childResourceIds = locationResources
        .Where(r => r.ParentResourceId == matchingResource.Id)
        .Select(r => r.Id)
        .ToList();

    if (childResourceIds.Count == 0) return childResourceAppointmentsToReturn;

    childResourceAppointmentsToReturn = resourceAppointments
        .Where(a => a.SelectedAppointmentResources
            .Any(r => childResourceIds.Contains(r.ResourceId)))
        .Select(la => ChildResourceAppointment.From(la, matchingResource.Id))
        .ToList();

    return childResourceAppointmentsToReturn;
}
```

## Benefits
- **Ease of Integration**: Works with existing database-first models—no refactoring required.
- **Explicit rather than Implicit**: The developer does not have to infer anything about the entity wrapped. If it’s wrapped in a type, it will be valid for that type’s usages.
- **Type Safety**: Specific wrappers (e.g., `ResourceAppointment`) ensure methods operate on validated states, enhanced by value types like `LocationId`.
- **Encapsulation**: Hides the raw entity, exposing only domain-relevant properties and actions.
- **Business Focus**: Constraints, progression, and value types reflect business rules, not just data structure.
- **Stepping Stone to DDD**: Introduces invariants, domain concepts, and value types without the full DDD overhead.
- **Reversible Actions**: Lazy state tracking with `isDirty` and `RevertToOriginal` allows undoing changes to scalar properties and child references efficiently, enhancing workflow flexibility.
- **Optimized Resource Use**: Original copies are created only when changes occur, reducing memory and CPU overhead in unchanged wrappers.
- **Primitive Obsession Mitigation**: Value types replace raw primitives, embedding validation and meaning directly in the domain model.

## Relation to Other Patterns
- **Wrapper/Adapter**: The core mechanic of wrapping an entity for a new purpose.
- **Decorator**: The progression of wrappers adds layers of behavior, though it’s more static than dynamic.
- **Type State**: Each wrapper represents a valid state, making invalid states unrepresentable.
- **Result Pattern**: Optional use of `Result<T>` for validation complements the constraint focus.
- **Memento**: The lazy original copy and `RevertToOriginal` resemble the Memento pattern, capturing and restoring state without exposing internals.
- **Value Object**: Value types align with DDD’s value object concept, encapsulating small, immutable domain concepts.

## When to Use It
- You’re starting with database-generated models and want to add domain logic.
- You need a simple way to enforce business rules without a major redesign.
- You want to guide a team toward DDD principles incrementally.
- You need reversible operations on entity states or richer domain types without heavy infrastructure.

## Limitations
- **Static Progression**: Unlike Decorators, the wrapper chain is predefined, limiting runtime flexibility.
- **Exposure Trade-Off**: While encapsulated, some properties (e.g., `LocationId`) must be exposed, requiring careful design. This can also be a benefit because the developer must think about what exactly they wish to expose.
- **Validation Overhead**: Adding constraints to every wrapper can feel repetitive without helper methods, but you don’t absolutely need to add constraints. Sometimes just the idea of having a wrapper type to guide developers through the state process is enough to merit its use.
- **Collection Management**: The base `Wrapper<T>` rollback doesn’t handle modifiable collections (e.g., `Appointments` in a `Resource`). Parent wrappers must track these separately, adding some complexity for list-heavy entities.
- **Tool Dependency**: State reversion relies on a mapping tool like AutoMapper for deep copies, introducing a minor external dependency.

## Conclusion
The Constrained Wrapper Pattern is a pragmatic bridge between database-first development and domain-centric design. By wrapping entities in type-safe, constrained shells, it shifts focus from raw data to business meaning—perfect for teams not ready for full DDD but wanting to head in that direction. The addition of lazy state tracking with `isDirty` and `RevertToOriginal` enhances its utility, allowing developers to experiment with changes and roll back as needed without upfront overhead, while value types like `LocationId` eliminate primitive obsession, embedding domain rules directly in the type system. Although collections require separate handling in parent wrappers, this hybrid approach maintains simplicity and flexibility. Whether you’re validating an `Appointment`’s location, managing a `Resource`’s schedulability, or refining workflows with reversible edits and richer types, this pattern offers a reusable, intuitive way to enforce rules, model processes, and adapt to evolving needs—all while keeping the codebase approachable.

---
