# The Constrained Entity Wrapper Pattern

## Overview
The **Constrained Wrapper Pattern** is a lightweight, type-safe design pattern for wrapping raw entities (e.g., database models) with domain-specific constraints and behaviors. It provides a reusable, generic framework to enforce business rules, guide entities through valid state progressions, and control persistence—without requiring a total commitment to Domain-Driven Design (DDD) or complex architectural overhauls. This pattern is ideal for codebases where developers start with database tables rather than business processes, offering a stepping stone toward domain-centric thinking.
### Key Features
- **Generic Base**: A `Wrapper<T>` class that wraps any entity type, providing a foundation for persistence and validation.
- **Type-Specific Subclasses**: Concrete wrappers (e.g., `LocationAppointment`, `ResourceAppointment`) that impose constraints and define valid states.
- **Progression**: Methods to transition between states (e.g., `ToResourceAppointment`), reflecting business workflows.
- **Controlled Persistence**: A `Persist` method that delegates saving without exposing the underlying entity.
- **Validation**: Constraints enforced via exceptions or a `Result<T>` type, ensuring invalid states are caught early.
### Intent
The Constrained Wrapper Pattern aims to:
- Add domain logic to database-first models without disrupting existing code.
- Shift focus from raw data to business processes in a pragmatic way.
- Enable type safety and encapsulation for entities in any codebase.
## Motivation
In many projects, development begins with database tables—think `Appointment` or `Resource` classes autogenerated from a schema. While this approach is quick to start, it often leaves business logic scattered or missing, treating objects as mere data containers rather than meaningful domain concepts. Full DDD can address this, but its complexity (aggregates, repositories, bounded contexts) can overwhelm teams not ready for that leap. The Constrained Entity Wrapper Pattern offers a middle ground: it wraps these raw entities in a type-safe, constrained shell that reflects business rules and workflows, making it easy to adopt and incrementally evolve toward DDD principles.

For example, an `Appointment` from a database might have a `LocationId`, but the business requires that it’s only valid for scheduling if that ID is set. Rather than exposing the raw `Appointment` and hoping callers check it, a `LocationAppointment` wrapper enforces this constraint, turning a generic row into a domain-specific concept.
## Structure
The pattern revolves around a generic base class and specific wrappers:
### Generic Base: `Wrapper<T>`
```csharp
public abstract class Wrapper<T>(T entity) where T : class  
{  
    protected internal readonly T Entity = entity ?? throw new ArgumentNullException(nameof(entity));  
  
    public void Persist(Action<T> saveAction) => saveAction(Entity);  
  
    // Helper for Result-based validation (optional, since you’re leaning toward exceptions)  
    protected static Result<U> Validate<U>(Func<bool> condition, string failureMessage, Func<U> create) => condition() ? Result.Failure<U>(failureMessage) : Result.Success(create());  
}
```
- **Purpose**: Provides a reusable foundation for wrapping any entity type (`T`), encapsulating it and offering a controlled persistence mechanism.
- **Key Elements**: A protected `Entity` field and a `Persist` method that delegates saving to an external action (e.g., a repository).

### Concrete Wrappers
Subclasses inherit from `Wrapper<T>` and add domain-specific constraints and behaviors. For example:

#### `LocationAppointment`
```csharp
public class LocationAppointment : Wrapper<Appointment>
{
    private LocationAppointment(Appointment appt) : base(appt)
    {
        if (appt.LocationId == Guid.Empty)
            throw new Exception("Appointment must have a valid LocationId");
        if (appt.BookedStart == DateTime.MinValue)
            throw new Exception($"{nameof(LocationAppointment)} must have a valid {nameof(Appointment.BookedStart)} date");
        if (appt.BookedEnd == DateTime.MinValue)
            throw new Exception($"{nameof(LocationAppointment)} must have a valid {nameof(Appointment.BookedEnd)} date");
    }

    public Guid LocationId => Entity.LocationId;
    public IReadOnlyCollection<SelectedAppointmentResource> SelectedAppointmentResources => Entity.SelectedAppointmentResources;
    public IReadOnlyCollection<SelectedAppointmentEmployee> SelectedAppointmentEmployees => Entity.SelectedAppointmentEmployees;
    public DateTime BookedStart => Entity.BookedStart;
    public DateTime BookedEnd => Entity.BookedEnd;

    public void SelectResource(MatchingResource matchingResource)
    {
        this.Entity.AddSelectedResource(matchingResource);
    }

    public static LocationAppointment From(Appointment appt) => new(appt);

    public ResourceAppointment ToResourceAppointment() 
        => ResourceAppointment.From(this); // TODO: See below

    public EmployeeAppointment ToEmployeeAppointment() 
        => EmployeeAppointment.From(this);
}
```
- **Constraints**: Ensures `LocationId` is valid.
- **Progression**: Offers a path to `ResourceAppointment` or `EmployeeAppointment`.

#### `ResourceAppointment`
```csharp
public class ResourceAppointment : Wrapper<Appointment>
{
    private ResourceAppointment(LocationAppointment locationAppointment) : base(locationAppointment.Entity)
    {
        if (locationAppointment.SelectedAppointmentResources.Count == 0)
            throw new Exception($"{nameof(ResourceAppointment)} requires one or more {nameof(SelectedAppointmentResource)}");
    }

    public IReadOnlyCollection<SelectedAppointmentResource> SelectedAppointmentResources => Entity.SelectedAppointmentResources;
    public DateTime BookedStart => Entity.BookedStart;
    public DateTime BookedEnd => Entity.BookedEnd;

    public static ResourceAppointment From(LocationAppointment locationAppointment) => new(locationAppointment);

    public Result<ParentResourceAppointment> AsParentResource(Guid parentResourceId)
        => ParentResourceAppointment.From(this, parentResourceId);

    public Result<ChildResourceAppointment> AsChildResource(Guid parentResourceId)
        => ChildResourceAppointment.From(this, parentResourceId);
}
```
- **Constraints**: Requires at least one resource.
- **Exposure**: Limits access to relevant properties.

## How It Works
1. **Wrapping**: Start with a raw entity (e.g., an `Appointment` from a database).
2. **Constraint Enforcement**: Use a factory method (`From`) to create a wrapper, applying validation (e.g., exceptions for missing `LocationId`).
3. **Progression**: Transition to other wrappers (e.g., `ToResourceAppointment`) as the business process evolves, each enforcing its own rules.
4. **Persistence**: Call `Persist` with a save action (e.g., `repo.Save`) to store the entity without exposing it.

### Example Usage
```csharp
public static List<ChildResourceAppointment> GetChildResourceAppointmentsOfMatchingResourceIfAny(
    List<ResourceAppointment> resourceAppointments,
    List<LocationResource> locationResources, 
    MatchingResource matchingResource)
{
    var childResourceAppointmentsToReturn = new List<ChildResourceAppointment>();
    
    // If this matchingResource is a parent on other resources then we need to check for any appointments
    // in the child resources and if they have appointments we need to build our availabilities based on
    // when all the children are available.
    var childResourceIds = locationResources
        .Where(r => r.ParentResourceId == matchingResource.Id)
        .Select(r => r.Id)
        .ToList();

    if (childResourceIds.Count == 0) return childResourceAppointmentsToReturn;

    childResourceAppointmentsToReturn = resourceAppointments
        .Where(a => a.SelectedAppointmentResources
            .Any(r => childResourceIds.Contains(r.ResourceId)))
        .Select(la => ChildResourceAppointment.From(la, matchingResource.Id))
        .ToList();

    return childResourceAppointmentsToReturn;
}
```
## Benefits
- **Ease of Integration**: Works with existing database-first models—no refactoring required.
- **Explicit rather than Implicit**: The developer does not have to infer anything about the entity wrapped. If it's wrapped in a type then it will be valid for that types usages.
- **Type Safety**: Specific wrappers (e.g., `ResourceAppointment`) ensure methods operate on validated states.
- **Encapsulation**: Hides the raw entity, exposing only domain-relevant properties and actions.
- **Business Focus**: Constraints and progression reflect business rules, not just data structure.
- **Stepping Stone to DDD**: Introduces invariants and domain concepts without the full DDD overhead.
## Relation to Other Patterns
- **Wrapper/Adapter**: The core mechanic of wrapping an entity for a new purpose.
- **Decorator**: The progression of wrappers adds layers of behavior, though it’s more static than dynamic.
- **Type State**: Each wrapper represents a valid state, making invalid states unrepresentable.
- **Result Pattern**: Optional use of `Result<T>` for validation complements the constraint focus.
## When to Use It
- You’re starting with database-generated models and want to add domain logic.
- You need a simple way to enforce business rules without a major redesign.
- You want to guide a team toward DDD principles incrementally.
## Limitations
- **Static Progression**: Unlike Decorators, the wrapper chain is predefined, limiting runtime flexibility.
- **Exposure Trade-Off**: While encapsulated, some properties (e.g., `LocationId`) must be exposed, requiring careful design. This can also be a benefit because the developer must think about what exactly they wish to expose.
- **Validation Overhead**: Adding constraints to every wrapper can feel repetitive without helper methods, but you don't absolutely need to add constraints. Sometimes just the idea of having a wrapper type to guide developers through the state process is enough to merit its use.
## Conclusion
The Constrained Wrapper Pattern is a pragmatic bridge between database-first development and domain-centric design. By wrapping entities in type-safe, constrained shells, it shifts focus from raw data to business meaning—perfect for teams not ready for full DDD but wanting to head in that direction. Whether you’re validating an `Appointment`’s location or a `Resource`’s schedulability, this pattern offers a reusable, intuitive way to enforce rules and model workflows, all while keeping the codebase approachable.

---
